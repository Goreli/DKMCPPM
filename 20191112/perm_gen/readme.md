# Generic Permutation Generator
<p align="center">Harmonious Discord of the Seemingly Distinct</p>

___

# Table of Contents
1. [Introduction](#introduction)
2. [Content Overview](#content-overview)
3. [Command Line Interface](#command-line-interface)
4. [Build Notes](#build-notes)
5. [Roadmap](#roadmap)
6. [Links](#links)

## Introduction

This directory contains C++ source code that has been written to address the String Permutation Generator challenge discussed at the Melbourne C++ Meetup Olympiad on 12/Nov/2019. At the core of the solution there is a reusable generic template header file that calculates permutations of sequences of arbitrary trivial C++ data types. A command line application has been implemented that provides an adaptation of the generic template to specifically generate textual (char) type permutations. A random permutation generator is available with this application exposing several algorithms via the command line interface. 
Also, another application has been developed to calculate bytewise entropy of input data that can help assess quality of the random permutation algorithms provided by the first application.

Application **str-perm-gen** generates and prints permutations of an input string specified on the command line or arriving via the standard input stream. Also, it exposes various convenience functions via respective command line options.

It may take long time to print all possible permutations of a long string. In general the combinatorial nature of the domain is associated with unstable performance whereby a slight increase of the input can cause a disproportionately large increase of the output. The application accepts command line arguments that help limit the number of permutations generated in order to keep performance within acceptable boundaries. A Regular Expressions (regex) syntax based filter is also available. Another way to improve performance is to write the output to a disk file instead of printing it on the screen. 

The application can be executed in a timing mode where it prints performance stats instead of printing permutations generated. This mode helps assess impact of various convenience functions on performance of the application.

The image below shows example output generated by the application. The following commands were executed:
```
./str-perm-gen -is Car
echo Car|./str-perm-gen -n 
```
![alt text](data/example_01.png "Example output of str-perm-gen-b and str-perm-gen.")

Application **calc-entropy** calculates and prints bytewise entropy of input data. The input data can be read from a file or standard input stream. It can optionally print the byte frequency table as well. By default the application works in the text mode that only processes printable bytes (those that, if printed, occupy space on the screen). There is a command line option that turns on the binary mode where all the input data is processed regardless of its printability. This application can be used to assess the quality of the random permutation generator provided with the **str-perm-gen** application.

The image below shows example output generated by the applications. First **str-perm-gen** was executed to create a file containing 40320 randomly generated permutations of the 12345678 sequence. Durstenfeld's random permutation algorithm was used. Next the **calc-entropy** application was executed twice: once to calculate entropy of the dataset in the text mode and the second time to do the calculation in the binary mode. Note how it reported larger content in the second run - this is because of the End-of-Line non-printable characters that were ignored in the first (text mode) run, but were processed in the second (binary mode) run. The following commands were executed:
```
./str-perm-gen -is 12345678 -c 40320 -rpa 2 -o rand_12345678.txt
./calc-entropy -i rand_12345678.txt
./calc-entropy -i rand_12345678.txt -b
```
![alt text](data/example_02.png "Random permutation generator example.")

## Content Overview

The project source code consists of the following components located in the [perm_gen](https://github.com/Goreli/DKMCPPM/tree/master/20191112/perm_gen) directory:
 * **perm_gen_base.hpp** - declares a template class called PermutationGeneratorBase. The class template provides a generic permutation generator that can process sequences of arbitrary trivial types. Populate *std::vector<T>* with the input sequence and pass it into the *generate(....)* function to start generating permutations of the sequence. Every time the generator generates a new permutation it passes the permutation into the *process_(....)* pure virtual function. Derived classes are responsible for utilising (printing, updating application variables etc) the permutations by overriding the *process_(....)* pure virtual function;
 * **perm_gen_base.inl** - this module defines the PermutationGeneratorBase template class and is included as a compilation unit at the end of perm_gen_base.hpp. Applications link the permutation generator in by including the perm_gen_base.hpp header file;
 * **cli_parser_base.hpp** - declares a helper class called CLIParserBase. The class provides certain convenience functions for command line applications that require parsing of command line options;
 * **cli_parser_base.cpp** - defines the CLIParserBase helper class;
 * **str_perm_gen_main.cpp** - the main entry module of the str-perm-gen application. It uses a dedicated command line interface to drive a string type specialisation of the generic permutation generator. The purpose is to provide a command line tool that efficiently delivers string permutations;
 * **str_perm_gen.hpp** - declares the string type specialisation of the permutation generator for the str-perm-gen application;
 * **str_perm_gen.cpp** - defines the string type specialisation of the permutation generator for the str-perm-gen application;
 * **str_perm_gen_cli.hpp** - declares the command line parser class for the str-perm-gen application. Utilises the CLIParserBase base class described above;
 * **str_perm_gen_cli.cpp** - defines the command line parser class for the str-perm-gen application;
 * **calc_entropy_main.cpp** - this is the main entry module of the calc-entropy application;
 * **calc_entropy_cli.hpp** - declares the command line parser class for the calc-entropy application. Utilises the CLIParserBase base class described above;
 * **calc_entropy_cli.cpp** - defines the command line parser class for the calc-entropy application.
  
## Command Line Interface
 
### CLI for str-perm-gen
str-perm-gen [options]

The following options are supported:
 * **+number** - starts printing at the specified permutation number. The permutation number is a 1 based number, not a 0 based index;
 * **-c count**  - the count of permutations to print;
 * **-er regex**  - excluding regex. Excludes permutations that match the regular expression;
 * **-g size**  - collects the permutations into consecutive groups of the specified size, then randomly picks one permutation from each consecutive group and prints them;
 * **-h**  - prints help information. This option overrides all other options. It allows to quickly request help information without deleting any of the other options that the user may have already typed on the command line. There is also a long version of this option that reads **--help**;
 * **-ir regex**  - including regex. Only prints permutations that match the regular expression;
 * **-is str**  - the input string to generate permutations of. When this option is missing the application expects the input string to arrive from the standard input stream;
 * **-l order**    - generates permutations arranged lexicographically in an ascending (literal **a**) or descending (literal **d**) order;
 * **-n** - prints permutation numbers (1 based numbers, not 0 based indices) at the start of each line. By default no permutation numbers are printed;
 * **-o path** - specifies the output file path. By default the output is printed on the screen. If this option is specified then the output is not printed on the screen and is written to the output file instead;
 * **-rpa id** - executes a random permutation algorithm. The following algorithms are supported: **1** - default algorithm, **2** - Richard Durstenfeld (modernised Fisher-Yates), **3** - Sandra Sattolo. This option is not compatible with option **-x**. Algorithm **1** stops after generating M! (M factorial) permutations where M is the number of symbols in the input sequence. Algorithms **2** and **3** don't stop generating random permutations unless the user explicitly specifies the maximum count with the **-c count** command line option. Also, the process can be interrupted by pressing the _Ctrl-C_ key combination;
 * **-s order** - pre-sorts the input string in ascending (literal **a**) or descending (literal **d**) order. By default the input string is not pre-sorted;
 * **-t repeat**  - times the application. The application follows all directives specified on the command line, but it doesn't actually output any permutations. It just dry-runs the user defined task several times and outputs the average duration. The **repeat** parameter specifies how many times the process should be executed before calculating the average duration. This option has no utility other than performance tuning;
 * **-x**  - excludes duplicate permutations. By default the application generates M! (M factorial) permutations, where M is the number of symbols in the input sequence. If there are duplicate symbols in the input sequence then, by default, the application lets duplicates into the output. However, with the **-x** option specified the application leaves the duplicate permutations out. As an example, by default, the application generates 6 permutations of the _'foo'_ sequence. However, with the **-x** option specified only 3 unique permutations of _'foo'_ are generated. This option is not compatible with the **-rpa** option.

The **-er** and **-ir** options are mutually exclusive. They provide light-weight support for regular expression based filtering and are expected to comply with the ECMAScript standard. The specification of the ECMAScript standard can be found here: http://www.cplusplus.com/reference/regex/ECMAScript/.

Note that not all regular expressions can be used interchangeably on the Windows and Linux command lines. This is because the different platforms use different escape characters and, in general, different command line syntax rules. This may cause unexpected behaviour of regular expressions when migrating them between the platforms. Part of the roadmap for this application is to develop a text file based regex filter in order to offer platform independent interpretation of regex expressions. Meanwhile the full power of regex expressions can be applied via the -er and -ir command line options as long as they are validated when migrating from one platform to another.

If the **-is** input string option is not specified then the application expects the input string to arrive from the standard input stream. In other words an alternative way of delivering the input string is to type it on the keyboard or provide piped input on the command line. Multiple strings are accepted from the standard input stream. Use the following key combinations to end the manual data entry:
 * on Windows - *[Ctrl+Z] followed by [Enter]*, or just *[Ctrl+C]*;
 * on Linux - *[Ctrl-D]*.

Refer the following link for an explanation of the difference between manual data entry termination keys used on the two platforms https://stackoverflow.com/questions/41222635/different-behaviour-of-ctrl-d-unix-and-ctrl-z-windows

Note that when piped input is used then each line of the input file is treated as a separate input string. This effect can be demonstrated using the following example:
```
echo Line 1  >example.txt
echo Line 2 >>example.txt
echo Line 3 >>example.txt
cat example.txt|./str-perm-gen -c 2
```

#### Example 1
    ./str-perm-gen -is Car +3 -c 2

The application skips the first two permutations. It starts printing beginning with the 3rd permutation and prints 2 permutations in total.

#### Example 2
    echo Car|./str-perm-gen +3 -c 2 -n 

Similar to the previous example. The difference is the application prints permutation numbers at the start of each line. Also, the input string is delivered via piped input.

#### Example 3
    ./str-perm-gen -is "Hi there!" +1300 -c 100 -n > permuted_greetings.txt

The application skips the first 1,299 permutations and starts printing beginning with permutation #1,300. It only prints 100 out of 362,880 possible permutations. Permutation numbers are printed at the start of each line. The output is redirected to the permuted_greetings.txt file, so nothing is actually displayed on the screen and all the output is saved in the disk file. Note that the redirection of standard output to the disk file improves performance of the process.

#### Example 4
    echo "Hi there!"|./str-perm-gen +1300 -c 100 -n -o permuted_greetings.txt

Similar to example 5. Note the -o option used to specify the output file.

#### Example 5
    ./str-perm-gen -is "Hello World" -n -ir " Hello$"

The inclusion type regex is used. The application only prints permutations that end with " Hello". Permutation numbers are printed at the start of each line.

### CLI for calc-entropy
calc-entropy [options]

The following options are supported:
 * **-b**  - binary mode. Process non-printable bytes as well as printable ones. By default the application is in the text mode and only processes printable bytes. When this option is specified and the input data is retrieved from a file (option **-i**) the application processes all input data regardless of its printability. This option is incompatible with option **-ft t** because, by definition, there is no way of displaying non-printable symbols in a text mode. Neither does it apply when the input data is retreived from the standard input stream;
 * **-ft param**  - prints a frequency table of constituent bytes as well as entropy value. Set **param** to a literal **n** to print the constituent bytes in a numeric format. Set **param** to a literal **t** to print the constituent bytes as printable characters. By default the application does not print the frequency table;
 * **-h**  - prints help information. This option overrides all other options. It allows to quickly request help information without deleting any of the other options that the user may have already typed on the command line. There is also a long version of this option: **--help**;
 * **-i path** - the path to the input data file to calculate entropy of. If this option is not specified then the application retrieves its input data from the standard input stream using either a manual entry or piped input; 
 * **-l base**  - by default the logarithm base used in the calculation equals the count of distinct bytes in the input file. This ensures the entropy value is normalised in the [0, 1] range. The **-l base** command line option allows to specify an alternative value for the logarithm base that helps to rescale entropy accordingly with a particular information measurement unit at use.

In the example below the logarithm base has been explicitly set to a 2 in order to express entropy in 2 based information measurement units (bits). Note that entropy of this random dataset composed of 8 distinct characters equals 3 bits. The following commands were executed:
```
./str-perm-gen -is 12345678 -c 40320 -rpa 2 -o rand_12345678.txt
./calc-entropy -i rand_12345678.txt -l 2
```

![alt text](data/example_03.png "Example of entropy expressed in bits.")

If the **-i** input file option is not specified then the application expects the input data to arrive from the standard input stream. In other words an alternative way of delivering the input data is to type it on the keyboard or provide piped input on the command line. Multiple strings are accepted from the standard input stream. Use the following key combinations to end the manual data entry:
 * on Windows - *[Ctrl+Z] followed by [Enter]*, or just *[Ctrl+C]*;
 * on Linux - *[Ctrl-D]*.

Refer the following link for an explanation of the difference between manual data entry termination keys used on the two platforms https://stackoverflow.com/questions/41222635/different-behaviour-of-ctrl-d-unix-and-ctrl-z-windows

Note that when piped input is used then each line of the input file is treated as a separate input string. This effect can be demonstrated using the following example:
```
echo Line 1  >example.txt
echo Line 2 >>example.txt
echo Line 3 >>example.txt
cat example.txt|./calc-entropy
```

## Build Notes

The project provides build system artefacts for two platforms. There is a CMakeLists.txt file in the [perm_gen](https://github.com/Goreli/DKMCPPM/tree/master/20191112/perm_gen) directory that can be processed with CMake to create build system artefacts on the Linux platform. There are also Visual Studio 2019 project files in the [vs_projects](https://github.com/Goreli/DKMCPPM/tree/master/20191112/perm_gen/vs_projects) subdirectory that build Windows executables.

There is a bash script called cmake-build.sh in the util subdirectory located under the root directory of the repository. This script automates the processing of the CMakeLists.txt file. Particularly, it accepts the toolchain name and target build type as command line arguments and creates respective subdirectories populated with build system artefacts. The Gnu and Clang toolchains are supported combined with the following build types: Release, Debug, RelWithDebInfo and MinSizeRel. Navigate to the [perm_gen](https://github.com/Goreli/DKMCPPM/tree/master/20191112/perm_gen) source directory and execute cmake-build.sh with proper command line arguments to create the required build system artefacts. Examples follow.

1. Clang, Release

Navigate to the source directory and create build system artefacts that will use the Clang compiler to create Release type binaries, then build the binaries.
```
/..../dkmcppm/20191112/perm_gen$ ../../util/cmake-build.sh Clang Release
/..../dkmcppm/20191112/perm_gen$ cd ClangRelease
/..../dkmcppm/20191112/perm_gen/ClangRelease$ make
```

2. Gnu, Debug

Navigate to the source directory and create build system artefacts that will use the Gnu compiler to create Debug type binaries, then build the binaries.
```
/..../dkmcppm/20191112/perm_gen$ ../../util/cmake-build.sh Gnu Debug
/..../dkmcppm/20191112/perm_gen$ cd GnuDebug
/..../dkmcppm/20191112/perm_gen/GnuDebug$ make
```

Here is a summary of Linux Makefile targets supported:

 * make all [Enter] (same as make [Enter]) - build all the three applications in the build subdirectory;
 * make str-perm-gen [Enter] - build str-perm-gen;
 * make calc-entropy [Enter] - build calc-entropy;
 * make clean [Enter] - remove all the three applications from the project directory;
 * make test_run [Enter] - tests str-perm-gen by printing 10 permutations of "Hello World";
 * make entropy [Enter] - generates 10 random permutations of "Hello World" and calculates entropy of the dataset generated.

To build Windows executables open the dkmccpm.sln solution file located in the root directory of the repository and navigate to this project in the VS 2019 Solution Explorer panel. The actual binaries are created in ../../x64.

Alternatively, add the project file(s) located in the [vs_projects](https://github.com/Goreli/DKMCPPM/tree/master/20191112/perm_gen/vs_projects) subdirectory to your existing VS 2019 solution.

Alternatively, use the CMakeLists.txt file supplied in the project directory to create your own Visual Studio project.

Here is the Visual Studio project configuration log:
1. Set the language standard to c++17;
2. Let the c++ compiler know the locations of include areas: ../..
3. Switch precompiled headers off;
4. Set the Command Line Arguments in the Debugging section to "Hello World". Make sure to include the double quoting marks.

## Roadmap

1. Develop a text file based regex filter in order to offer platform independent interpretation of regex expressions as well as an advanced filtering facility. In this application performance bottleneck is caused by the output stream, so it should be possible to manage the regex overhead by taking a multithreading based approach;
2. Explore ways to use concurrency or async (or plain C io) to boost performance of the output stream (refer https://stackoverflow.com/questions/21126950/asynchronously-writing-to-a-file-in-c-unix);
3. Dynamically linked installable random permutation providers.

## Links

1. Melbourne C++ Meetup on meetup.com:
	https://www.meetup.com/MelbourneCpp/
2. Melbourne C++ Meetup on GitHub.com:
	https://github.com/melbourne-cpp
3. Melbourne C++ Meetup Olympiad materials on GitHub.com: 
	https://github.com/melbourne-cpp/olympiad
4. The Olympiad Wiki page on GitHub.com: 
	https://github.com/melbourne-cpp/olympiad/wiki
5. This repository on GitHub.com:
	https://github.com/Goreli/DKMCPPM
6. This solution on GitHub.com:
	https://github.com/Goreli/DKMCPPM/tree/master/20191112/perm_gen
7. Permutation on Wikipedia.org:
	https://en.wikipedia.org/wiki/Permutation#Generation_with_minimal_changes
8. Fisher-Yates Shuffle on Wikipedia.org:
	https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle
9. Robert Sedgewick, Permutation Generation Methods, Computing Surveys, Vol 9, No 2, June 1977
	https://www.princeton.edu/~rblee/ELE572Papers/p137-sedgewick.pdf
